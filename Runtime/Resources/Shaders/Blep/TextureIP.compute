#include "TextureCommon.hlsl"
#pragma kernel Grayscale
#pragma kernel GrayscaleGamma
#pragma kernel Threshold
#pragma kernel ConvertRGB2HSV
#pragma kernel ConvertHSV2RGB
#pragma kernel Swizzle
#pragma kernel Lookup
#pragma kernel FlipHorizontal
#pragma kernel FlipVertical
#pragma kernel Rotate180
#pragma kernel Erode
#pragma kernel Dilate
#pragma kernel BlurGaussian
#pragma kernel RecursiveConvolveFwd
#pragma kernel RecursiveConvolveBak
#pragma kernel Skeletonize
#pragma kernel Sobel
#pragma kernel Scharr
#pragma kernel ComposeOver
#pragma kernel ComposeIn
#pragma kernel ComposeOut
#pragma kernel ComposeAtop
#pragma kernel ComposeXor
#pragma kernel ComposePlus
#pragma kernel HistogramEqClear
#pragma kernel HistogramEqGather
#pragma kernel HistogramEqAccumulate
#pragma kernel HistogramEqMap
#pragma kernel MaxReduce
#pragma kernel MinReduce
#pragma kernel SumReduce

Texture2D<float4> SrcA;
Texture2D<float4> SrcB;
float4 ScalarA;
float4 ScalarB;
RWTexture2D<float4> Dst;
RWStructuredBuffer<uint4> Histogram;

// -------------------------------------------------------------------------------
// Color conversion functions

// Converts color in linear space  to Unity gamma space
inline float4 Linear2Gamma(float4 color) {
    // Approximation
    // from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1
    color.rgb = max(color.rgb, float3(0, 0, 0));
    color.rgb = max(1.055 * pow(color.rgb, 0.416666667) - 0.055, 0);
    return color;
}

// Converts color in Unity gamma space to linear space
inline float4 Gamma2Linear(float4 color) {
    // Approximate
    // From https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
    color.rgb = color.rgb * (color.rgb * (color.rgb * 0.305306011 + 0.682171111) + 0.012522878);
    return color;
}

inline float4 RGB2HSV(float4 c) {
    // From https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
    float4 K = float4(0.0f, -1.0f / 3.0f, 2.0f / 3.0f, -1.0f);
    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10f;
    return float4(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x, c.a);
}

inline float4 HSV2RGB(float4 c) {
    //  https://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness
    float4 K = float4(1.0f, 2.0f / 3.0f, 1.0f / 3.0f, 3.0f);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0f - K.www);
    return float4(c.z * lerp(K.xxx, saturate(p - K.xxx), c.y), c.a);
}

// -------------------------------------------------------------------------------
// Color conversion

[numthreads(THREADSX, THREADSY, 1)]
void Grayscale(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 color = SrcA[xy];
        float lum = dot(color.rgb, float3(0.2126, 0.7152, 0.0722));
        Dst[xy] = float4(lum, lum, lum, color.a);
    }
}

// Convert to linear, then grayscale, then back to gamma
// See https://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
[numthreads(THREADSX, THREADSY, 1)]
void GrayscaleGamma(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 color = Gamma2Linear(SrcA[xy]);
        float lum = dot(color.rgb, float3(0.2126, 0.7152, 0.0722));
        Dst[xy] = Linear2Gamma(float4(lum, lum, lum, color.a));
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void Threshold(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        Dst[xy] = step(ScalarA, SrcA[xy]);
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void ConvertRGB2HSV(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        Dst[xy] = RGB2HSV(SrcA[xy]);
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void ConvertHSV2RGB(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        Dst[xy] = HSV2RGB(SrcA[xy]);
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void Swizzle(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        uint4 channels = uint4(ScalarA);
        float4 color = SrcA[xy];
        Dst[xy] = float4(color[channels.x],
                         color[channels.y],
                         color[channels.z],
                         color[channels.w]);
    }
}

// Use color values in SrcA as indicies into pallette SrcB
[numthreads(THREADSX, THREADSY, 1)]
void Lookup(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 color = SrcA[xy];
        Dst[xy] = float4(SampleLinear(SrcB, float2(color.r, 0)).r,
                         SampleLinear(SrcB, float2(color.g, 0)).g,
                         SampleLinear(SrcB, float2(color.b, 0)).b,
                         SampleLinear(SrcB, float2(color.a, 0)).a);
    }
}

// -------------------------------------------------------------------------------
// Geometric

[numthreads(THREADSX, THREADSY, 1)]
void FlipHorizontal(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        Dst[xy] = SrcA[uint2(TextureSize.x - xy.x - 1, xy.y)];
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void FlipVertical(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        Dst[xy] = SrcA[uint2(xy.x, TextureSize.y - xy.y - 1)];
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void Rotate180(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        Dst[xy] = SrcA[TextureSize - xy - 1];
    }
}

// -------------------------------------------------------------------------------
// Morphology etc

[numthreads(THREADSX, THREADSY, 1)]
void Erode(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        uint2 xySE = max(0, xy - 1);
        uint2 xyNW = min(TextureSize - 1, xy + 1);

        float4 SE = SrcA[xySE];
        float4 SO = SrcA[uint2(xy  .x, xySE.y)];
        float4 SW = SrcA[uint2(xySE.x, xySE.y)];
        float4 EA = SrcA[uint2(xySE.x, xy  .y)];
        float4 WE = SrcA[uint2(xyNW.x, xy  .y)];
        float4 NE = SrcA[uint2(xySE.x, xyNW.y)];
        float4 NO = SrcA[uint2(xy  .x, xyNW.y)];
        float4 NW = SrcA[xyNW];

        float4 nbrMin = min(min(min(SE, SO), min(SW, EA)),
                            min(min(WE, NE), min(NO, NW)));
        Dst[xy] = min(SrcA[xy], nbrMin);
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void Dilate(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        uint2 xySE = max(0, xy - 1);
        uint2 xyNW = min(TextureSize - 1, xy + 1);

        float4 SE = SrcA[xySE];
        float4 SO = SrcA[uint2(xy  .x, xySE.y)];
        float4 SW = SrcA[uint2(xySE.x, xySE.y)];
        float4 EA = SrcA[uint2(xySE.x, xy  .y)];
        float4 WE = SrcA[uint2(xyNW.x, xy  .y)];
        float4 NE = SrcA[uint2(xySE.x, xyNW.y)];
        float4 NO = SrcA[uint2(xy  .x, xyNW.y)];
        float4 NW = SrcA[xyNW];

        float4 nbrMax = max(max(max(SE, SO), max(SW, EA)),
                            max(max(WE, NE), max(NO, NW)));
        Dst[xy] = max(SrcA[xy], nbrMax);
    }
}

// A Fast Parallel Algorithm for Thinning Digital Patterns, T. Y. Zhang and C. Y. Suen
// Reference implementation here: https://github.com/dingmyu/thinning_Zhan-Suen
[numthreads(THREADSX, THREADSY, 1)]
void Skeletonize(uint2 xy : SV_DispatchThreadID) {
    // Ignore outermost pixels
    if (all(xy > uint2(0, 0) && xy < TextureSize - uint2(1,1))) {
        // Get 8-neighbours
        uint SE = uint(SrcA[xy + int2(-1, -1)].r);
        uint SO = uint(SrcA[xy + int2( 0, -1)].r);
        uint SW = uint(SrcA[xy + int2( 1, -1)].r);
        uint EA = uint(SrcA[xy + int2(-1,  0)].r);
        uint WE = uint(SrcA[xy + int2( 1,  0)].r);
        uint NE = uint(SrcA[xy + int2(-1,  1)].r);
        uint NO = uint(SrcA[xy + int2( 0,  1)].r);
        uint NW = uint(SrcA[xy + int2( 1,  1)].r);

        // Arrange in clockwise order
        uint neighbors = (EA << 7 | NE << 6 | NO << 5 | NW << 4 | WE << 3 | SW << 2 | SO << 1 | SE);

        // How many neighbors are on
        uint count = countbits(neighbors);

        // How many transitions from off to on
        // Left rotate bits by one, xor with original bits, and and with rotated-bits
        uint neighborsRotated = ((neighbors << 1) & 0xff) | (neighbors >> 7);
        uint transitions = (neighbors ^ neighborsRotated) & neighborsRotated;
        uint transitionCount = countbits(transitions);

        // Weird neighbor test, different for each iteration
        // Iter ? (EA * SO * NO == 0) && (EA * SO * WE == 0)
        //      : (NO * WE * EA == 0) && (NO * WE * SO == 0)
        bool iter = ScalarA.x > 0;
        bool neighborTest = iter
            ? ! all(uint3(EA, SO, NO + WE))
            : ! all(uint3(NO, WE, EA + SO));

        // If all tests pass, turn off the pixel
        if (transitionCount == 1 && count >= 2 && count <= 6 && neighborTest) {
            Dst[xy] = 0;
        }
        else {
            Dst[xy] = SrcA[xy].r;
        }
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void Sobel(uint2 xy : SV_DispatchThreadID) {
    // Ignore outermost pixels
    if (all(xy > uint2(0, 0) && xy < TextureSize - uint2(1,1))) {
        // Get 8-neighbours
        float4 SE = SrcA[xy + int2(-1, -1)];
        float4 SO = SrcA[xy + int2( 0, -1)];
        float4 SW = SrcA[xy + int2( 1, -1)];
        float4 EA = SrcA[xy + int2(-1,  0)];
        float4 WE = SrcA[xy + int2( 1,  0)];
        float4 NE = SrcA[xy + int2(-1,  1)];
        float4 NO = SrcA[xy + int2( 0,  1)];
        float4 NW = SrcA[xy + int2( 1,  1)];

        float4 dx = (NW - NE) + 2 * (WE - EA) + (SW - SE);
        float4 dy = (NW - SW) + 2 * (NO - SO) + (NE - SE);

        Dst[xy] = saturate(sqrt(dx * dx + dy * dy));
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void Scharr(uint2 xy : SV_DispatchThreadID) {
    // Ignore outermost pixels
    if (all(xy > uint2(0, 0) && xy < TextureSize - uint2(1,1))) {

        // Get 8-neighbours
        float4 SE = SrcA[xy + int2(-1, -1)];
        float4 SO = SrcA[xy + int2( 0, -1)];
        float4 SW = SrcA[xy + int2( 1, -1)];
        float4 EA = SrcA[xy + int2(-1,  0)];
        float4 WE = SrcA[xy + int2( 1,  0)];
        float4 NE = SrcA[xy + int2(-1,  1)];
        float4 NO = SrcA[xy + int2( 0,  1)];
        float4 NW = SrcA[xy + int2( 1,  1)];

        float4 dx = 3 * (NW - NE + SW - SE) + 10 * (WE - EA);
        float4 dy = 3 * (NW - SW + NE - SE) + 10 * (NO - SO);

        Dst[xy] = saturate(sqrt(dx * dx + dy * dy));
    }
}

// -------------------------------------------------------------------------------
// Blurring

// Incremental gaussian
// TODO/SPEED: Transpose after first pass?
// https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-40-incremental-computation-gaussian
[numthreads(THREADSX, THREADSY, 1)]
void BlurGaussian(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float2 uv = GetUV(xy);

        float3 incGauss = ScalarA.xyz;
        float size = ScalarA.w;
        float2 direction = ScalarB.xy;

        float4 color = SamplePoint(SrcA, uv) * incGauss.x;
        float  sum = incGauss.x;
        incGauss.xy *= incGauss.yz;

        float2 delta = direction * TexelSize.xy;
        int halfSize = int(ceil((size - 1) * 0.5));
        for (int i = 1; i <= halfSize; i++) {
            float2 offset = i * delta;
            color += incGauss.x * (SamplePoint(SrcA, uv - offset) +
                                   SamplePoint(SrcA, uv + offset));
            sum += 2 * incGauss.x;
            incGauss.xy *= incGauss.yz;
        }

        Dst[xy] = color / sum;

    }
}

// Recursive convolution
// see https://www.researchgate.net/publication/222453003_Recursive_implementation_of_the_Gaussian_filter

// Unused slow method.
[numthreads(THREADSX * THREADSY, 1, 1)]
void RecursiveConvolve(uint2 xy : SV_DispatchThreadID) {
    uint rowOrCol = xy.x;

    float4 coeffs = ScalarA;
    int2 direction = int2(ScalarB.xy);

    bool isForward = any(direction > 0);
    bool isHorizontal = direction.y == 0;

    if (rowOrCol < (isHorizontal ? TextureSize.y : TextureSize.x)) {

        uint count = isHorizontal ? TextureSize.x : TextureSize.y;
        uint start = isForward ? 0 : count - 1;
        uint2 idx = isHorizontal ? uint2(start, rowOrCol) : uint2(rowOrCol, start);

        float4x4 prevM = { SrcA[idx], SrcA[idx], SrcA[idx], SrcA[idx] };

        for (uint i = 0; i < count; ++i, idx += direction) {

            prevM[0] = SrcA[idx];
            float4 val = mul(coeffs, prevM);
            prevM[3] = prevM[2];
            prevM[2] = prevM[1];
            prevM[1] = val;

            Dst[idx] = val;
        }
    }
}

// Run through each row forwards
[numthreads(THREADSX * THREADSY, 1, 1)]
void RecursiveConvolveFwd(uint y : SV_DispatchThreadID) {
    if (y < TextureSize.y) {

        float4 coeffs = ScalarA;
        uint2 idx = uint2(0, y);
        uint count = TextureSize.x;

        float4x4 prevM = { SrcA[idx], SrcA[idx], SrcA[idx], SrcA[idx] };

        for (uint i = 0; i < count; ++i, idx += uint2(1, 0)) {
            prevM[0] = SrcA[idx];
            float4 val = mul(coeffs, prevM);
            prevM[3] = prevM[2];
            prevM[2] = prevM[1];
            prevM[1] = val;

            Dst[idx] = val;
        }
    }
}

// Run through each row backwards and traspose output
[numthreads(THREADSX * THREADSY, 1, 1)]
void RecursiveConvolveBak(uint y : SV_DispatchThreadID) {
    if (y < TextureSize.y) {

        float4 coeffs = ScalarA;
        uint2 idx = uint2(TextureSize.x - 1, y);
        uint count = TextureSize.x;

        float4x4 prevM = { SrcA[idx], SrcA[idx], SrcA[idx], SrcA[idx] };

        for (uint i = 0; i < count; ++i, idx -= uint2(1, 0)) {
            prevM[0] = SrcA[idx];
            float4 val = mul(coeffs, prevM);
            prevM[3] = prevM[2];
            prevM[2] = prevM[1];
            prevM[1] = val;

            // Transpose
            Dst[idx.yx] = val;
        }
    }
}

// -------------------------------------------------------------------------------
// Histogram

[numthreads(256, 1, 1)]
void HistogramEqClear(uint x : SV_DispatchThreadID) {
    Histogram[x] = uint4(0, 0, 0, 0);
}

// TODO/SPEED: Isolate threads to prevent collisions
[numthreads(THREADSX, THREADSY, 1)]
void HistogramEqGather(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        uint4 col = uint4(255.999 * SrcA[xy]);
        InterlockedAdd(Histogram[col.r].r, 1);
        InterlockedAdd(Histogram[col.g].g, 1);
        InterlockedAdd(Histogram[col.b].b, 1);
        InterlockedAdd(Histogram[col.a].a, 1);
    }
}

[numthreads(1, 1, 1)]
//[numthreads(256, 1, 1)]
void HistogramEqAccumulate(uint x : SV_DispatchThreadID) {

    for (uint d = 1; d < 256; d++) {
        Histogram[d] += Histogram[d - 1];
    }

    // GroupMemoryBarrierWithGroupSync doesn't seem to work on Metal (?), so do it serially.
    // Recursive doubling algorithm: On the first pass, the value one element to
    // the left is added to the current value. On the second pass, the value two
    // elements to the left is added the current value. In general, the stride
    // is doubled for each pass. See:
    // https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.8836

    //for (uint d = 1; d <= 128; d <<= 1) {
    //  if (id.x >= d) {
    //    Histogram[id.x] += Histogram[id.x - d];
    //  }
    //}
    //GroupMemoryBarrierWithGroupSync();
}

[numthreads(THREADSX, THREADSY, 1)]
void HistogramEqMap(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 col = SrcA[xy];
        uint4 col255 = uint4(255.999f * col);
        float3 colMapped = float3(Histogram[col255.r].r,
                                  Histogram[col255.g].g,
                                  Histogram[col255.b].b) * (TexelSize.x * TexelSize.y);
        Dst[xy] = float4(colMapped, col.a);
    }
}

// -------------------------------------------------------------------------------
// Stats

// Not very cohesive memory access.

[numthreads(THREADSX, THREADSY, 1)]
void MaxReduce(uint2 xy : SV_DispatchThreadID) {
    uint2 offset = (TextureSize + 1) >> 1;
    if (all(xy < offset)) {
        uint2 last = TextureSize - 1;

        float4 WE = SrcA[min(xy + uint2(offset.x, 0), last)];
        float4 NO = SrcA[min(xy + uint2(0, offset.y), last)];
        float4 NW = SrcA[min(xy + offset            , last)];

        Dst[xy] = max(max(SrcA[xy], WE), max(NO, NW));
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void MinReduce(uint2 xy : SV_DispatchThreadID) {
    uint2 offset = (TextureSize + 1) >> 1;
    if (all(xy < offset)) {
        uint2 last = TextureSize - 1;

        float4 WE = SrcA[min(xy + uint2(offset.x, 0), last)];
        float4 NO = SrcA[min(xy + uint2(0, offset.y), last)];
        float4 NW = SrcA[min(xy + offset            , last)];

        Dst[xy] = min(min(SrcA[xy], WE), min(NO, NW));
    }
}

[numthreads(THREADSX, THREADSY, 1)]
void SumReduce(uint2 xy : SV_DispatchThreadID) {
    uint2 offset = (TextureSize + 1) >> 1;
    if (all(xy < offset)) {

        uint2 xyNW = xy + offset;
        float4 WE = xyNW.x   < TextureSize.x ? SrcA[uint2(xyNW.x, xy.y)] : 0;
        float4 NO = xyNW.y   < TextureSize.y ? SrcA[uint2(xy.x, xyNW.y)] : 0;
        float4 NW = all(xyNW < TextureSize)  ? SrcA[xyNW] : 0;

        Dst[xy] = SrcA[xy] + WE + NO + NW;
    }
}

/*
// Cohesive memory access but requires two tmp buffers

[numthreads(THREADSX, THREADSY, 1)]
void MaxReduce(uint2 xy : SV_DispatchThreadID) {
  if (all(xy < (TextureSize + 1) >> 1)) {
    uint2 xySrc = xy * 2;
    uint2 xySrcNW = min(xySrc + 1, TextureSize - 1);

    float4 WE = SrcA[uint2(xySrcNW.x, xySrc  .y)];
    float4 NO = SrcA[uint2(xySrc  .x, xySrcNW.y)];
    float4 NW = SrcA[xySrcNW];

    Dst[xy] = max(max(SrcA[xySrc], WE), max(NO, NW));
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void MinReduce(uint2 xy : SV_DispatchThreadID) {
  if (all(xy < (TextureSize + 1) >> 1)) {
    uint2 xySrc = xy * 2;
    uint2 xySrcNW = min(xySrc + 1, TextureSize - 1);

    float4 WE = SrcA[uint2(xySrcNW.x, xySrc  .y)];
    float4 NO = SrcA[uint2(xySrc  .x, xySrcNW.y)];
    float4 NW = SrcA[xySrcNW];

    Dst[xy] = min(min(SrcA[xySrc], WE), min(NO, NW));
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void SumReduce(uint2 xy : SV_DispatchThreadID) {
  if (all(xy < (TextureSize + 1) >> 1)) {
    uint2 xySrc = xy * 2;
    uint2 xySrcNW = xySrc + 1;

    // TODO: Faster to use Load, which is guaranteed to return 0 out of bounds?
    float4 WE = xySrcNW.x < TextureSize.x  ? SrcA[xySrc + uint2(1, 0)] : 0;
    float4 NO = xySrcNW.y < TextureSize.y  ? SrcA[xySrc + uint2(0, 1)] : 0;
    float4 NW = all(xySrcNW < TextureSize) ? SrcA[xySrcNW] : 0;

    Dst[xy] = SrcA[xySrc.xy] + WE + NO + NW;
  }
}

*/

// -------------------------------------------------------------------------------
// Composition

// Over
// αA*A+(1- αA)* αB*B
// αA+(1-αA)* αB
// A occludes B
[numthreads(THREADSX, THREADSY, 1)]
void ComposeOver(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 colorA = SrcA[xy];
        float4 colorB = SrcB[xy];
        colorA.rgb *= colorA.a;
        colorB.rgb *= colorB.a;
        Dst[xy] = lerp(colorB, float4(colorA.rgb, 1), colorA.a);
    }
}

// IN
// αA*A*αB
// αA*αB
// A within B. B acts as a matte for A. A shows only where B is visible.
[numthreads(THREADSX, THREADSY, 1)]
void ComposeIn(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 colorA = SrcA[xy];
        float4 colorB = SrcB[xy];
        colorA.rgb *= colorA.a;
        Dst[xy] = colorA * colorB.a;
    }
}

// OUT
// αA*A*(1-αB)
// αA*(1-αB)
// A outside B. NOT-B acts as a matte for A. A shows only where B is not visible.
[numthreads(THREADSX, THREADSY, 1)]
void ComposeOut(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 colorA = SrcA[xy];
        float4 colorB = SrcB[xy];
        colorA.rgb *= colorA.a;
        Dst[xy] = colorA * (1 - colorB.a);
    }
}

// ATOP
// αA*A*αB+(1- αA)* αB*B
// αA*αB+(1- αA)* αB
[numthreads(THREADSX, THREADSY, 1)]
void ComposeAtop(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 colorA = SrcA[xy];
        float4 colorB = SrcB[xy];
        Dst[xy] = float4(lerp(colorB.rgb, colorA.rgb, colorA.a) * colorB.a, colorB.a);
    }
}

// XOR
// αA*A*(1-αB)+(1- αA)* αB*B = lerp(aB * B, A * (1 - aB), aA) = lerp(aA * A, (1-aA)*B, aB)
// αA*(1-αB)+(1- αA)* αB =
// Combination of (A OUT B) and (B OUT A). A and B mutually exclude each other.
[numthreads(THREADSX, THREADSY, 1)]
void ComposeXor(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 colorA = SrcA[xy];
        float4 colorB = SrcB[xy];
        colorA.rgb *= colorA.a;
        colorB.rgb *= colorB.a;
        Dst[xy] = saturate(colorA * (1 - colorB.a) + colorB * (1 - colorA.a));
    }
}

// PLUS
// αA*A+αB*B
// αA+αB
// Blend without precedence
[numthreads(THREADSX, THREADSY, 1)]
void ComposePlus(uint2 xy : SV_DispatchThreadID) {
    if (InRange(xy)) {
        float4 colorA = SrcA[xy];
        float4 colorB = SrcB[xy];
        colorA.rgb *= colorA.a;
        colorB.rgb *= colorB.a;
        Dst[xy] = saturate(colorA + colorB);
    }
}
