#include "TextureCommon.hlsl"
#pragma kernel Circle
#pragma kernel CircleI
#pragma kernel Line
#pragma kernel LineI
#pragma kernel Border
#pragma kernel BorderI

Texture2D<float4> SrcA;
Texture2D<float4> SrcB;
float4 ScalarA;
float4 ScalarB;
float4 ScalarC;
RWTexture2D<float4> Dst;

// Sets dst color based on distance to edge and falloff
float4 GetColor(float4 srcColor, float4 color, float sdf, float falloff) {
    float alpha = color.a * smoothstep(0, -falloff, sdf);
    return lerp(srcColor, float4(color.rgb, 1), alpha);
}


// Sets dst to ScalarA in the circle described by ScalarB (ctr.x, ctr.y, rad, falloff)
void Circle(uint2 xy, float4 srcColor) {
    if (InRange(xy)) {
        float4 color = ScalarA;
        float2 center = ScalarB.xy;
        float radius = ScalarB.z;
        float falloff = ScalarB.w;
        float sdf = distance(xy, center) - radius;
        Dst[xy] = GetColor(srcColor, color, sdf, falloff);
    }
}

// Sets dst to ScalarA in the line described by ScalarB (p.x, p.y, q.x, q.y)
// with width and falloff in ScalarC
void Line(uint2 xy, float4 srcColor) {
    if (InRange(xy)) {
        float4 color = ScalarA;
        float2 p = ScalarB.xy;
        float2 q = ScalarB.zw;
        float halfWidth = ScalarC.x * 0.5f;
        float falloff = ScalarC.y;

        // Project uv onto the line p-q,, clamp to (0, 1)
        float2 pq = p - q;
        float lenSqr = dot(pq, pq);
        float t = lenSqr < 0.0000001f ? 0 : dot(xy - q, pq) / lenSqr;
        float2 closest = q + saturate(t) * pq;
        float sdf = distance(xy, closest) - halfWidth;

        Dst[xy] = GetColor(srcColor, color, sdf, falloff);
    }
}

// Sets dst to ScalarA along the border described by ScalarB (width, falloff)
void Border(uint2 xy, float4 srcColor) {
    if (InRange(xy)) {
        float4 color = ScalarA;
        float width = ScalarB.x;
        float falloff = ScalarB.y;

        float2 halfSize = (TextureSize.xy - 1) * 0.5;
        float2 d2 = halfSize - abs(xy - halfSize);
        float sdf = min(d2.x, d2.y) - width;

        Dst[xy] = GetColor(srcColor, color, sdf, falloff);
    }
}

// ------------------------------------------------------------------------------------------

[numthreads(THREADSX, THREADSY, 1)]
void Circle(uint2 xy : SV_DispatchThreadID) {
    Circle(xy, SrcA[xy]);
}

[numthreads(THREADSX, THREADSY, 1)]
void CircleI(uint2 xy : SV_DispatchThreadID) {
    Circle(xy, Dst[xy]);
}

[numthreads(THREADSX, THREADSY, 1)]
void Line(uint2 xy : SV_DispatchThreadID) {
    Line(xy, SrcA[xy]);
}

[numthreads(THREADSX, THREADSY, 1)]
void LineI(uint2 xy : SV_DispatchThreadID) {
    Line(xy, Dst[xy]);
}

[numthreads(THREADSX, THREADSY, 1)]
void Border(uint2 xy : SV_DispatchThreadID) {
    Border(xy, SrcA[xy]);
}

[numthreads(THREADSX, THREADSY, 1)]
void BorderI(uint2 xy : SV_DispatchThreadID) {
    Border(xy, Dst[xy]);
}
