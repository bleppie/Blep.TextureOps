#include "TextureCommon.hlsl"
#pragma kernel Grayscale
#pragma kernel GrayscaleGamma
#pragma kernel Threshold
#pragma kernel ConvertRGB2HSV
#pragma kernel ConvertHSV2RGB
#pragma kernel Swizzle
#pragma kernel Lookup
#pragma kernel FlipHorizontal
#pragma kernel FlipVertical
#pragma kernel Rotate180
#pragma kernel Erode
#pragma kernel Dilate
#pragma kernel BlurGaussian
#pragma kernel RecursiveConvolve
#pragma kernel Skeletonize
#pragma kernel Sobel
#pragma kernel Scharr
#pragma kernel ComposeOver
#pragma kernel ComposeIn
#pragma kernel ComposeOut
#pragma kernel ComposeAtop
#pragma kernel ComposeXor
#pragma kernel ComposePlus
#pragma kernel HistogramEqClear
#pragma kernel HistogramEqGather
#pragma kernel HistogramEqAccumulate
#pragma kernel HistogramEqMap
#pragma kernel MaxReduce
#pragma kernel MinReduce
#pragma kernel SumReduce

Texture2D<float4> SrcA;
Texture2D<float4> SrcB;
float4 ScalarA;
float4 ScalarB;
RWTexture2D<float4> Dst;
RWStructuredBuffer<uint4> Histogram;

// -------------------------------------------------------------------------------
// Color conversion functions

inline float4 Linear2Gamma(float4 color) {
  // Approximation
	// from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1
  color.rgb = max(color.rgb, float3(0, 0, 0));
  color.rgb = max(1.055 * pow(color.rgb, 0.416666667) - 0.055, 0);
  return color;
}

inline float4 Gamma2Linear(float4 color) {
  // Approximate
  // from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1
  color.rgb = color.rgb * (color.rgb * (color.rgb * 0.305306011 + 0.682171111) + 0.012522878);
  return color;
}

inline float4 RGB2HSV(float4 c) {
  //  https://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness
  float4 K = float4(0.0f, -1.0f / 3.0f, 2.0f / 3.0f, -1.0f);
  float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
  float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10f;
  return float4(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x, c.a);
}

inline float4 HSV2RGB(float4 c) {
  //  https://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness
  float4 K = float4(1.0f, 2.0f / 3.0f, 1.0f / 3.0f, 3.0f);
  float3 p = abs(frac(c.xxx + K.xyz) * 6.0f - K.www);
  return float4(c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y), c.a);
}

// -------------------------------------------------------------------------------
// Color conversion

[numthreads(THREADSX, THREADSY, 1)]
void Grayscale(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		float4 color = SrcA[xy];
		float lum = dot(color.rgb, float3(0.2126, 0.7152, 0.0722));
		Dst[xy] = float4(lum, lum, lum, color.a);
	}
}

// See https://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
[numthreads(THREADSX, THREADSY, 1)]
void GrayscaleGamma(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		float4 color = Gamma2Linear(SrcA[xy]);
		float lum = dot(color.rgb, float3(0.2126, 0.7152, 0.0722));
		Dst[xy] = Linear2Gamma(float4(lum, lum, lum, color.a));
	}
}

[numthreads(THREADSX, THREADSY, 1)]
void Threshold(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		Dst[xy] = step(ScalarA, SrcA[xy]);
	}
}

[numthreads(THREADSX, THREADSY, 1)]
void ConvertRGB2HSV(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		Dst[xy] = RGB2HSV(SrcA[xy]);
	}
}

[numthreads(THREADSX, THREADSY, 1)]
void ConvertHSV2RGB(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		Dst[xy] = HSV2RGB(SrcA[xy]);
	}
}

[numthreads(THREADSX, THREADSY, 1)]
void Swizzle(uint2 xy : SV_DispatchThreadID) {
  if (InRange(xy)) {
    uint4 channels = uint4(ScalarA);
    float4 color = SrcA[xy];
    Dst[xy] = float4(color[channels.x],
                        color[channels.y],
                        color[channels.z],
                        color[channels.w]);
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void Lookup(uint2 xy : SV_DispatchThreadID) {
  if (InRange(xy)) {
    float4 color = SrcA[xy];
    Dst[xy] = float4(SampleLinear(SrcB, float2(color.r, 0)).r,
                        SampleLinear(SrcB, float2(color.g, 0)).g,
                        SampleLinear(SrcB, float2(color.b, 0)).b,
                        SampleLinear(SrcB, float2(color.a, 0)).a);
  }
}

// -------------------------------------------------------------------------------
// Geometric

[numthreads(THREADSX, THREADSY, 1)]
void FlipHorizontal(uint2 xy : SV_DispatchThreadID) {
  if (InRange(xy)) {
    Dst[xy] = SrcA[uint2(TextureSize.x - xy.x - 1, xy.y)];
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void FlipVertical(uint2 xy : SV_DispatchThreadID) {
  if (InRange(xy)) {
    Dst[xy] = SrcA[uint2(xy.x, TextureSize.y - xy.y - 1)];
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void Rotate180(uint2 xy : SV_DispatchThreadID) {
  if (InRange(xy)) {
    Dst[xy] = SrcA[TextureSize - xy - 1];
  }
}

// -------------------------------------------------------------------------------
// Morphology etc

[numthreads(THREADSX, THREADSY, 1)]
void Erode(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
        uint2 xySE = max(0, xy - 1);
    uint2 xyNW = min(TextureSize - 1, xy + 1);

    float4 SE = SrcA[xySE];
    float4 SO = SrcA[uint2(xy  .x, xySE.y)];
    float4 SW = SrcA[uint2(xySE.x, xySE.y)];
    float4 EA = SrcA[uint2(xySE.x, xy  .y)];
    float4 WE = SrcA[uint2(xyNW.x, xy  .y)];
    float4 NE = SrcA[uint2(xySE.x, xyNW.y)];
    float4 NO = SrcA[uint2(xy  .x, xyNW.y)];
    float4 NW = SrcA[xyNW];

    float4 nbrMin = min(min(min(SE, SO), min(SW, EA)),
                        min(min(WE, NE), min(NO, NW)));
    Dst[xy] = min(SrcA[xy], nbrMin);
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void Dilate(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
        uint2 xySE = max(0, xy - 1);
    uint2 xyNW = min(TextureSize - 1, xy + 1);

    float4 SE = SrcA[xySE];
    float4 SO = SrcA[uint2(xy  .x, xySE.y)];
    float4 SW = SrcA[uint2(xySE.x, xySE.y)];
    float4 EA = SrcA[uint2(xySE.x, xy  .y)];
    float4 WE = SrcA[uint2(xyNW.x, xy  .y)];
    float4 NE = SrcA[uint2(xySE.x, xyNW.y)];
    float4 NO = SrcA[uint2(xy  .x, xyNW.y)];
    float4 NW = SrcA[xyNW];

    float4 nbrMax = max(max(max(SE, SO), max(SW, EA)),
                        max(max(WE, NE), max(NO, NW)));
    Dst[xy] = max(SrcA[xy], nbrMax);
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void Skeletonize(uint2 xy : SV_DispatchThreadID) {
  // Ignore outermost pixels
  if (all(xy > uint2(0, 0) && xy < TextureSize - uint2(1,1))) {
    // Get 8-neighbours
    uint SE = uint(SrcA[xy + int2(-1, -1)].r);
    uint SO = uint(SrcA[xy + int2( 0, -1)].r);
    uint SW = uint(SrcA[xy + int2( 1, -1)].r);
    uint EA = uint(SrcA[xy + int2(-1,  0)].r);
    uint WE = uint(SrcA[xy + int2( 1,  0)].r);
    uint NE = uint(SrcA[xy + int2(-1,  1)].r);
    uint NO = uint(SrcA[xy + int2( 0,  1)].r);
    uint NW = uint(SrcA[xy + int2( 1,  1)].r);

    // Arrange in clockwise order
    uint neighbors = (EA << 7 | NE << 6 | NO << 5 | NW << 4 | WE << 3 | SW << 2 | SO << 1 | SE);

    // How many neighbors are on
    uint count = countbits(neighbors);

    // How many transitions from off to on
    // Left rotate bits by one, xor with original bits, and and with rotated-bits
    uint neighborsRotated = ((neighbors << 1) & 0xff) | (neighbors >> 7);
    uint transitions = (neighbors ^ neighborsRotated) & neighborsRotated;
    uint transitionCount = countbits(transitions);

    // Weird neighbor test, different for each iteration
    // Iter ? (EA * SO * NO == 0) && (EA * SO * WE == 0)
    //      : (NO * WE * EA == 0) && (NO * WE * SO == 0)
    bool iter = ScalarA.x > 0;
    bool neighborTest = iter
      ? ! all(uint3(EA, SO, NO + WE))
      : ! all(uint3(NO, WE, EA + SO));

    // If all tests pass, turn off the pixel
    if (transitionCount == 1 && count >= 2 && count <= 6 && neighborTest) {
      Dst[xy] = 0;
    }
    else {
      Dst[xy] = SrcA[xy].r;
    }
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void Sobel(uint2 xy : SV_DispatchThreadID) {
  // Ignore outermost pixels
  if (all(xy > uint2(0, 0) && xy < TextureSize - uint2(1,1))) {
    // Get 8-neighbours
    float4 SE = SrcA[xy + int2(-1, -1)];
    float4 SO = SrcA[xy + int2( 0, -1)];
    float4 SW = SrcA[xy + int2( 1, -1)];
    float4 EA = SrcA[xy + int2(-1,  0)];
    float4 WE = SrcA[xy + int2( 1,  0)];
    float4 NE = SrcA[xy + int2(-1,  1)];
    float4 NO = SrcA[xy + int2( 0,  1)];
    float4 NW = SrcA[xy + int2( 1,  1)];

    float4 dx = (NW - NE) + 2 * (WE - EA) + (SW - SE);
    float4 dy = (NW - SW) + 2 * (NO - SO) + (NE - SE);

    Dst[xy] = saturate(sqrt(dx * dx + dy * dy));
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void Scharr(uint2 xy : SV_DispatchThreadID) {
  // Ignore outermost pixels
  if (all(xy > uint2(0, 0) && xy < TextureSize - uint2(1,1))) {

    // Get 8-neighbours
    float4 SE = SrcA[xy + int2(-1, -1)];
    float4 SO = SrcA[xy + int2( 0, -1)];
    float4 SW = SrcA[xy + int2( 1, -1)];
    float4 EA = SrcA[xy + int2(-1,  0)];
    float4 WE = SrcA[xy + int2( 1,  0)];
    float4 NE = SrcA[xy + int2(-1,  1)];
    float4 NO = SrcA[xy + int2( 0,  1)];
    float4 NW = SrcA[xy + int2( 1,  1)];

    float4 dx = 3 * (NW - NE + SW - SE) + 10 * (WE - EA);
    float4 dy = 3 * (NW - SW + NE - SE) + 10 * (NO - SO);

    Dst[xy] = saturate(sqrt(dx * dx + dy * dy));
  }
}

// -------------------------------------------------------------------------------
// Blurring

[numthreads(THREADSX, THREADSY, 1)]
void BlurGaussian(uint2 xy : SV_DispatchThreadID) {
  if (InRange(xy)) {
    float2 uv = GetUV(xy);

    float3 incGauss = ScalarA.xyz;
    float size = ScalarA.w;
    float2 direction = ScalarB.xy;

    float4 color = SamplePoint(SrcA, uv) * incGauss.x;
    float  sum = incGauss.x;
    incGauss.xy *= incGauss.yz;

    // Go through the remaining samples
    float2 delta = direction * TexelSize.xy;
    int halfSize = int(ceil((size - 1) * 0.5));
    for (int i = 1; i <= halfSize; i++) {
      float2 offset = i * delta;
      color += incGauss.x * (SamplePoint(SrcA, uv - offset) +
                             SamplePoint(SrcA, uv + offset));
      sum += 2 * incGauss.x;
      incGauss.xy *= incGauss.yz;
    }

    Dst[xy] = color / sum;

  }
}

[numthreads(THREADSX * THREADSY, 1, 1)]
void RecursiveConvolve(uint2 xy : SV_DispatchThreadID) {
  uint rowOrCol = xy.x;

  float4 coeffs = ScalarA;
  int2 direction = int2(ScalarB.xy);

  bool isForward = any(direction > 0);
  bool isHorizontal = direction.y == 0;

  if (rowOrCol < (isHorizontal ? TextureSize.y : TextureSize.x)) {

    uint count = isHorizontal ? TextureSize.x : TextureSize.y;
    uint start = isForward ? 0 : count - 1;
    uint2 idx = isHorizontal ? uint2(start, rowOrCol) : uint2(rowOrCol, start);

    float4x4 prevM = { SrcA[idx], SrcA[idx], SrcA[idx], SrcA[idx] };

    for (uint i = 0; i < count; ++i, idx += direction) {

      // val = coeffs.x * Src + coeffs.y * prev0 + coeffs.z * prev1 + coeffs.w * prev2;
      // prev2 = prev1;
      // prev1 = prev0;
      // prev0 = val;

      prevM[0] = SrcA[idx];
      float4 val = mul(coeffs, prevM);
      prevM[3] = prevM[2];
      prevM[2] = prevM[1];
      prevM[1] = val;

      Dst[idx] = val;

    }

  }
}

// -------------------------------------------------------------------------------
// Histogram

[numthreads(256, 1, 1)]
void HistogramEqClear(uint x : SV_DispatchThreadID) {
  Histogram[x] = uint4(0, 0, 0, 0);
}

// TODO/SPEED: Isolate threads to prevent collisions
[numthreads(THREADSX, THREADSY, 1)]
void HistogramEqGather(uint2 xy : SV_DispatchThreadID) {
		if (InRange(xy)) {
				uint4 col = uint4(255.999 * SrcA[xy]);
				InterlockedAdd(Histogram[col.r].r, 1);
				InterlockedAdd(Histogram[col.g].g, 1);
				InterlockedAdd(Histogram[col.b].b, 1);
				InterlockedAdd(Histogram[col.a].a, 1);
		}
}

[numthreads(1, 1, 1)]
//[numthreads(256, 1, 1)]
void HistogramEqAccumulate(uint x : SV_DispatchThreadID) {

  for (uint d = 1; d < 256; d++) {
      Histogram[d] += Histogram[d - 1];
  }

  // GroupMemoryBarrierWithGroupSync doesn't seem to work on Metal, so do it serially
  // Recursive doubling algorithm: On the first pass, the value one element to
  // the left is added to the current value. On the second pass, the value two
  // elements to the left is added the current value. In general, the stride
  // is doubled for each pass. See:
  // https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.8836

  //for (uint d = 1; d <= 128; d <<= 1) {
  //  if (id.x >= d) {
  //    Histogram[id.x] += Histogram[id.x - d];
  //  }
  //}
  //GroupMemoryBarrierWithGroupSync();
}

[numthreads(THREADSX, THREADSY, 1)]
void HistogramEqMap(uint2 xy : SV_DispatchThreadID) {
  if (InRange(xy)) {
    float4 col = SrcA[xy];
    uint4 col255 = uint4(255.999f * col);
    float3 colMapped = float3(Histogram[col255.r].r,
                              Histogram[col255.g].g,
                              Histogram[col255.b].b) * (TexelSize.x * TexelSize.y);
    Dst[xy] = float4(colMapped, col.a);
  }
}

// -------------------------------------------------------------------------------
// Stats

[numthreads(THREADSX, THREADSY, 1)]
void MaxReduce(uint2 xy : SV_DispatchThreadID) {
  if (all(xy < (TextureSize + 1) / 2)) {
    uint2 xySrc = xy * 2;
    uint2 xySrcNW = min(xySrc + 1, TextureSize - 1);

    float4 WE = SrcA[uint2(xySrcNW.x, xySrc  .y)];
    float4 NO = SrcA[uint2(xySrc  .x, xySrcNW.y)];
    float4 NW = SrcA[xySrcNW];

    Dst[xy] = max(max(SrcA[xySrc], WE), max(NO, NW));
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void MinReduce(uint2 xy : SV_DispatchThreadID) {
  if (all(xy < (TextureSize + 1) / 2)) {
    uint2 xySrc = xy * 2;
    uint2 xySrcNW = min(xySrc + 1, TextureSize - 1);

    float4 WE = SrcA[uint2(xySrcNW.x, xySrc  .y)];
    float4 NO = SrcA[uint2(xySrc  .x, xySrcNW.y)];
    float4 NW = SrcA[xySrcNW];

    Dst[xy] = min(min(SrcA[xySrc], WE), min(NO, NW));
  }
}

[numthreads(THREADSX, THREADSY, 1)]
void SumReduce(uint2 xy : SV_DispatchThreadID) {
  if (all(xy < (TextureSize + 1) / 2)) {
    uint2 xySrc = xy * 2;
    uint2 xySrcNW = xySrc + 1;

    // TODO: Faster to use Load, which is guaranteed to return 0 out of bounds?
    float4 WE = xySrcNW.x < TextureSize.x  ? SrcA[xySrc + uint2(1, 0)] : 0;
    float4 NO = xySrcNW.y < TextureSize.y  ? SrcA[xySrc + uint2(0, 1)] : 0;
    float4 NW = all(xySrcNW < TextureSize) ? SrcA[xySrcNW] : 0;

    Dst[xy] = SrcA[xySrc.xy] + WE + NO + NW;
  }
}


// -------------------------------------------------------------------------------
// Composition

// Over
// αA*A+(1- αA)* αB*B
// αA+(1-αA)* αB
// A occludes B
[numthreads(THREADSX, THREADSY, 1)]
void ComposeOver(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		float4 colorA = SrcA[xy];
		float4 colorB = SrcB[xy];
		colorA.rgb *= colorA.a;
		colorB.rgb *= colorB.a;
		Dst[xy] = lerp(colorB, float4(colorA.rgb, 1), colorA.a);
	}
}

// IN
// αA*A*αB
// αA*αB
// A within B. B acts as a matte for A. A shows only where B is visible.
[numthreads(THREADSX, THREADSY, 1)]
void ComposeIn(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		float4 colorA = SrcA[xy];
		float4 colorB = SrcB[xy];
		colorA.rgb *= colorA.a;
		Dst[xy] = colorA * colorB.a;
	}
}

// OUT
// αA*A*(1-αB)
// αA*(1-αB)
// A outside B. NOT-B acts as a matte for A. A shows only where B is not visible.
[numthreads(THREADSX, THREADSY, 1)]
void ComposeOut(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		float4 colorA = SrcA[xy];
		float4 colorB = SrcB[xy];
		colorA.rgb *= colorA.a;
		Dst[xy] = colorA * (1 - colorB.a);
	}
}

// ATOP
// αA*A*αB+(1- αA)* αB*B
// αA*αB+(1- αA)* αB
[numthreads(THREADSX, THREADSY, 1)]
void ComposeAtop(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		float4 colorA = SrcA[xy];
		float4 colorB = SrcB[xy];
		Dst[xy] = float4(lerp(colorB.rgb, colorA.rgb, colorA.a) * colorB.a, colorB.a);
	}
}

// XOR
// αA*A*(1-αB)+(1- αA)* αB*B = lerp(aB * B, A * (1 - aB), aA) = lerp(aA * A, (1-aA)*B, aB)
// αA*(1-αB)+(1- αA)* αB =
// Combination of (A OUT B) and (B OUT A). A and B mutually exclude each other.
[numthreads(THREADSX, THREADSY, 1)]
void ComposeXor(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		float4 colorA = SrcA[xy];
		float4 colorB = SrcB[xy];
		colorA.rgb *= colorA.a;
		colorB.rgb *= colorB.a;
		Dst[xy] = saturate(colorA * (1 - colorB.a) + colorB * (1 - colorA.a));
	}
}

// PLUS
// αA*A+αB*B
// αA+αB
// Blend without precedence
[numthreads(THREADSX, THREADSY, 1)]
void ComposePlus(uint2 xy : SV_DispatchThreadID) {
	if (InRange(xy)) {
		float4 colorA = SrcA[xy];
		float4 colorB = SrcB[xy];
		colorA.rgb *= colorA.a;
		colorB.rgb *= colorB.a;
		Dst[xy] = saturate(colorA + colorB);
	}
}
